#!/usr/bin/env node

var commander = require('commander-b');
var blog = require('hatena-blog-api');
var path = require('path');
var fs = require('fs');

var newClient = function() {
  return blog({
    type: 'wsse',
    username: process.env.HATENA_USERNAME,
    blogId: process.env.HATENA_BLOG_ID,
    apiKey: process.env.HATENA_API_KEY || process.env.HATENA_APIKEY
  });
};

var getVersion = function() {
  var packageJsonPath = path.resolve(__dirname, './../package.json');
  var packageJson = require(packageJsonPath);
  return packageJson.version
};

var formatEntry = function(e) {
  var id = e.id._.match(/^tag:[^:]+:[^-]+-[^-]+-\d+-(\d+)$/)[1];
  var title = e.title._;
  var url = e.link.filter(function(l) {
    return l.$.rel === 'alternate';
  })[0].$.href;
  return ['id: ' + id, 'title: ' + title, 'url: ' + url].join('\n')
};

var parseJekyllMarkdown = function(content) {
  var yaml = require('js-yaml');
  var pattern = /^---$\n*([\s\S]*?)\n*^---$\n*([\s\S]*)/m;
  var match = content.match(pattern);
  var headerString = match[1];
  var headers = yaml.safeLoad(headerString);
  var content = match[2];
  return { headers: headers, content: content };
};

var command = commander()
var program = command.version(getVersion());

program
.command('index', 'index entries')
.action(function() {
  var client = newClient();
  return client.index().then(function(res) {
    console.log(res.feed.entry.map(formatEntry).join('\n'));
  }, function(err) {
    console.error(err);
  });
});

program
.command('create <file>', 'create an entry')
.option('-t, --title <title>', 'title')
.option('-d, --draft', 'draft')
.option('-j, --jekyll', 'jekyll markdown')
.action(function(file, options) {
  var client = newClient();
  var params = { content: fs.readFileSync(file, { encoding: 'utf8' }) };
  if (options.jekyll) {
    var parsed = parseJekyllMarkdown(params.content);
    params.content = parsed.content;
    if (parsed.headers.title) params.title = parsed.headers.title;
    // bouzuya's markdown
    if (parsed.headers.pubdate || parsed.headers.updated)
      params.updated = parsed.headers.pubdate || parsed.headers.updated;
  }
  if (options.draft) params.draft = true;
  if (options.title) params.title = options.title;
  return client.create(params).then(function(res) {
    console.log(formatEntry(res.entry));
  }, function(err) {
    console.error(err);
  });
});

program
.command('show <id>', 'show an entry')
.action(function(id) {
  var client = newClient();
  return client.show({ id: id }).then(function(res) {
    console.log(formatEntry(res.entry));
  }, function(err) {
    console.error(err);
  });
});


program
.command('update <id> <file>', 'update an entry')
.option('-t, --title <title>', 'title')
.option('-d, --draft', 'draft')
.option('-j, --jekyll', 'jekyll markdown')
.action(function(id, file, options) {
  var params = { id: id, content: fs.readFileSync(file, { encoding: 'utf8' }) };
  if (options.jekyll) {
    var parsed = parseJekyllMarkdown(params.content);
    params.content = parsed.content;
    if (parsed.headers.title) params.title = parsed.headers.title;
    // bouzuya's markdown
    if (parsed.headers.pubdate || parsed.headers.updated)
      params.updated = parsed.headers.pubdate || parsed.headers.updated;
  }
  if (options.title) params.title = options.title;
  if (options.draft) params.draft = true;
  var client = newClient();
  return client.update(params).then(function(res) {
    console.log(formatEntry(res.entry));
  }, function(err) {
    console.error(err);
  });
});

program
.command('destroy <id>', 'destroy an entry')
.action(function(id) {
  var client = newClient();
  return client.destroy({ id: id }).then(function(res) {
    console.log('deleted');
  }, function(err) {
    console.error(err);
  });
});

program.execute();
